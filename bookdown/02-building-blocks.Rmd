# Building Blocks

A typical machine learning workflow looks like this:

```{r ml_abstract_fig, echo = FALSE}
knitr::include_graphics("images/ml_abstraction.png")
```

The `mlr3` package provides objects for the building blocks [tasks](#tasks), [learners](#learners) and [measures](#measures).


## Tasks {#tasks}

Learning tasks encapsulate the data set and additional meta information about a machine learning problem, for example the name of the target variable for supervised problems.

### Task Types

To manually create a task from a `r ref("base::data.frame()")` or `r ref("data.table()")`, you must first determine the task type to select the respective constructor:


* Classification Task: Target column is labels (stored as `character()`/`factor()`) with only few distinct values.
  <br>$\Rightarrow$ `r ref("mlr3::TaskClassif")`
* Regression Task: Target column is numeric (stored as `integer()`/`double()`).
  <br>$\Rightarrow$ `r ref("mlr3::TaskRegr")`
* Survival Task: Target is the (right-censored) time to event.
  <br>$\Rightarrow$ `r ref("mlr3survival::TaskSurv")` in add-on package `r mlr_pkg("mlr3surival")`
* Ordinal Regression Task: Target is ordinal.
  <br>$\Rightarrow$ `r ref("mlr3ordinal::TaskOrdinal")` in add-on package `r mlr_pkg("mlr3ordinal")`
* Cluster Task: You don't have a target but want to identify similarities in the feature space.
  <br>$\Rightarrow$ Not yet implemented


### Task Creation

Let's assume we want to create a simple regression task using the `mtcars` data set from the package `datasets` to predict the column `"mpg"` (miles per gallon).
We only take the first two features here to keep the output in the following examples compact.

```{r 02-building-blocks-1}
data("mtcars", package = "datasets")
data = mtcars[, 1:3]
str(data)
```

Next, we create the task by providing the following information:

1. `id`: identifier for the task, used in plots and summaries.
2. `backend`: here, we simply provide the `data.frame()` which is internally converted to a `r ref("DataBackendDataTable")`.
   For more fine-grain control over how the data is stored internally, we could also construct a `r ref("DataBackend")` manually.
3. `target`: Column name of the target column for the regression problem.

```{r 02-building-blocks-2}
task_mtcars = TaskRegr$new(id = "cars", backend = data, target = "mpg")
print(task_mtcars)
```

The `print()` method gives a short summary of the task: It has `r task_mtcars$nrow` observations, `r task_mtcars$ncol` columns of which `r length(task_mtcars$feature_names)` columns are features.


### Predefined tasks

`mlr3` ships with some predefined machine learning tasks.
These are stored in a `r ref("Dictionary")`, which is a simple key-value store named `mlr3::mlr_tasks`.
We can obtain a summarizing overview of all stored tasks by converting the dictionary to a `data.table()`
```{r 02-building-blocks-3}
as.data.table(mlr_tasks)
```

For illustration purposes, we now retrieve the popular [iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set) from `mlr_tasks` as a classification task:

```{r 02-building-blocks-4}
task_iris = mlr_tasks$get("iris")
print(task_iris)
```

### Task API
The task properties and characteristics can be queried using the task's public member values and methods (see `r ref("Task")`).
Most of them should be self-explanatory, e.g.,

```{r 02-building-blocks-5}
task_iris = mlr_tasks$get("iris")

# public member values
task_iris$nrow
task_iris$ncol

# public member methods
task_iris$head(n = 3)
```

#### Retrieve Data
In `mlr3`, each row (observation) has a unique identifier which can be either `integer()` or `character()`.
These can be used to select specific rows.

```{r 02-building-blocks-6}
# iris uses integer row_ids
head(task_iris$row_ids)

# retrieve data for rows with ids 1, 51, and 101
task_iris$data(rows = c(1, 51, 101))

# mtcars uses the rownames of the original data set
head(task_mtcars$row_ids)

# retrieve data for rows with id "Datsun 710"
task_mtcars$data(rows = "Datsun 710")
```

Note that the method `$data()` is only an accessor and does not modify the underlying data/task.

Analogously, each column has an identifier, which is often just called column name.
These are stored in the public fields `feature_names` and `target_names`:

```{r 02-building-blocks-7}
task_iris$feature_names
task_iris$target_names

# retrieve data for rows 1, 51, and 101 and only select column "Species"
task_iris$data(rows = c(1, 51, 101), cols = "Species")
```

To retrieve the complete data set, e.g. for a closer inspection, convert to a `data.table()`:
```{r 02-building-blocks-8}
summary(as.data.table(task_iris))
```


#### Roles

It is possible to assign special roles to (subsets of) rows and columns.

For example, the previously constructed mtcars task has the following column roles:
```{r 02-building-blocks-9}
task_mtcars$col_roles
```

Now, we want the original `rownames()` of `mtcars` to be a regular feature column.
Thus, we first pre-process the `data.frame` and then re-create the task.

```{r 02-building-blocks-10}
library("data.table")
# with `keep.rownames`, data.table stores the row names in an extra column "rn"
data = as.data.table(mtcars[, 1:3], keep.rownames = TRUE)
task = TaskRegr$new(id = "cars", backend = data, target = "mpg")

# we now have integer row_ids
task$row_ids

# there is a new "feature" called "rn"
task$feature_names
```

The column "rn" is now a regular feature.
As this is a unique string column, most machine learning algorithms will have problems to process this feature without some kind of preprocessing.
However, we still might want to carry `rn` around for different reasons.
E.g., we can use the row names in plots or to associate outliers with the row names.
This being said, we need to change the role of the row names column `rn` and remove it from the set of active features.

```{r 02-building-blocks-11}
task$feature_names
task$set_col_role("rn", new_roles = "label")

# "rn" not listed as feature any more
task$feature_names

# also vanished from "data" and "head"
task$data(rows = 1:2)
task$head(2)
```

Note that no copies of the underlying data is inflicted by this operation.
By changing roles, only the view on the data is changed, not the data itself.

Just like columns, it is also possible to assign different roles to rows.
Rows can have two different roles:

1. Role `"use"`:
   Rows that are generally available for model fitting (although they may also be used as test set in resampling).
   This is the default role.
2. Role `"validation"`:
   Rows that are held back (see below).
   Rows which have missing values in the target column upon task creation are automatically moved to the validation set.

There are several reasons to hold some observations back or treat them differently:

1. It is often good practice to validate the final model on an external validation set to uncover possible overfitting
2. Some observations may be unlabeled, e.g. in data mining cups or [Kaggle](https://www.kaggle.com/) competitions.
   These observations cannot be used for training a model, but you can still predict labels.

#### Task Mutators

The methods `set_col_role()` and `set_row_role()` change the view on the data and can be used to subset the task.
For convenience, the method `filter()` subsets the task based on row ids, and `select()` subsets the task based on feature names.
All these operations only change the view on the data, without creating a copy of it, but modify the task in-place.
```{r 02-building-blocks-12}
task = mlr_tasks$get("iris")
task$select(c("Sepal.Width", "Sepal.Length")) # keep only these features
task$filter(1:3) # keep only these rows
task$head()
```


Additionally, the methods `rbind()` and `cbind()` allow to add extra rows and columns to a task, respectively.
The method `replace_features()` is a convenience wrapper around `select()` and `cbind()`.
Again, the original data set stored in the original `mlr3::DataBackend` is not altered in any way.
```{r 02-building-blocks-13}
task$cbind(data.table(foo = letters[1:3])) # add column foo
task$head()
```



## Learners {#learners}

Objects of class `mlr3::Learner` provide a unified interface to many popular machine learning algorithms in R.
They consist of methods to train and predict on a `mlr3::Task`, and additionally provide meta information about the algorithms.

The package ships with only a rather minimal set of classification and regression learners, more are implemented in the [mlr3learners](https://mlr3learners.mlr-org.com) package.
Furthermore, [mlr3learners](https://mlr3learners.mlr-org.com) has some documentation on creating custom learners.


### Predefined Learners

Analogously to `mlr3::mlr_tasks`, the `mlr3::Dictionary` `mlr3::mlr_learners` can be queried for available learners:

```{r 02-building-blocks-14}
mlr_learners
as.data.table(mlr_learners)
```

As listed in the output, each learner comes with the following annotations:

* `feature_types`: what kind of features can be processed.
* `packages`: which packages are required to run `train()` and `predict()`.
* `properties`: additional properties and capabilities. E.g., a learner has the property "missings" if it is able to
  handle missing values natively, and "importance" if it is possible to extract feature importance values.
* `predict_types`: what predict types are possible. E.g., a classification learner can predict labels ("response") or probabilities ("prob")

To extract a specific learner, use the corresponding "id":
```{r 02-building-blocks-15}
learner = mlr_learners$get("classif.rpart")
learner
```
As the printer shows, all information from the previous table is also accessible via public fields (`id`, `feature_types`, `packages`, `properties`, `predict_types`)
Additionally, `predict_type` returns the currently selected predict type of the learner.

The field `param_set` stores a description of hyperparameter settings:
```{r 02-building-blocks-16}
learner$param_set
```
The set of hyperparamter values is stored inside the parameter set in the field `values`.
By assigning a named list to this field, we change the active hyperparameters of the learner:
```{r 02-building-blocks-17}
learner$param_set$values = list(cp = 0.01)
learner
```

The field `model` stores the result of the training step.
As we have not yet learned a model, this is `NULL`:
```{r 02-building-blocks-18}
learner$model
```

### Train and Predict

Is recommended to train the learner via the `mlr3::Experiment` class, we only train the learner here directly to showcase more of its API.

First, we retrieve the "iris" task from the `mlr3::mlr_tasks` dictionary, and then apply the train method on the complete task.
```{r 02-building-blocks-19}
task = mlr_tasks$get("iris")
learner$train(task)
```
The learner returns itself, the fitted model is stored in the field "model":
```{r 02-building-blocks-20}
learner$model
```

Next, we generate predictions on the complete iris data set:
```{r 02-building-blocks-21}
predictions = learner$predict(task)
```
The returned `mlr3::PredictionClassif` object stores the predicted labels ("response") as well as the true labels ("truth").

By simply counting the number of correct predictions and dividing by the number of observations, we can calculate the accuracy:
```{r 02-building-blocks-22}
tab = as.data.table(predictions)
mean(tab$response == tab$truth)
```
Note that this measure is over-optimistic.
As we did not used an independent test set, this is the re-substitution error.

### Adding a new learner

Since mlr aims to be entensible, you can easily add a new learner and register it with mlr.
This process is done in 8 steps:

1. Clone the [`mlr-org/mlr3learners`](https://www.github.com/mlr-org/mlr3learners) repository.
1. Adding a new R source file in `R/mlr_learners_[classif/regr]_[your learner name].R` by first deciding on whether you want to implement a classificator or regression learner and then choosing a short name for your learner like "ranger" or "xgboost".
2. Copy the contents of `R/template_[classif/regr].R` into your new learner implementation and follow the comments in the template. Replace all occurences of `template` with your chosen learner abbreviation. Look at the other learner implementations for tips and help.
3. Register your learner in `R/zzz.R` under either classification or regression learners.
4. Add a test for your learner: Copy the file `tests/autotest_template.R` into the folder `tests/testthat/` and name it `test_[classif/regr]_[your learner name].R`. You don't have to register your test.
5. You can either submit a pull request (PR) for your learner in the mlr3learners repository or use your fork of mlr3learners to use the learner.

- Todo: Maybe add more explanation to the things.

## Performance Measures {#measures}

Typically, performance measures are defined alongside a machine learning task.

